package compiler.generated;
import java_cup.runtime.*;


parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

//TERMINALS

terminal ABSTRACT;
terminal ASSERT;
terminal BOOLEAN;
terminal BREAK;
terminal BYTE;
terminal CASE;
terminal CATCH;
terminal CHAR;
terminal CLASS;
terminal CONST;
terminal CONTINUE;
terminal DEFAULT;
terminal DO;
terminal DOUBLE;
terminal ELSE;
terminal ENUM;
terminal EXTENDS;
terminal FALSE;
terminal FINAL;
terminal FINALLY;
terminal FLOAT;
terminal FOR;
terminal IF;
terminal GOTO;
terminal IMPLEMENTS;
terminal IMPORT;
terminal INSTANCEOF;
terminal INT;
terminal INTERFACE;
terminal LONG;
terminal NATIVE;
terminal NEW;
terminal NULL;
terminal PACKAGE;
terminal PRIVATE;
terminal PROTECTED;
terminal PUBLIC;
terminal RETURN;
terminal SHORT;
terminal STATIC;
terminal SUPER;
terminal SWITCH;
terminal SYNCHRONIZED;
terminal THIS;
terminal THREADSAFE;
terminal THROW;
terminal THROWS;
terminal TRANSIENT;
terminal TRUE;
terminal TRY;
terminal VOID;
terminal VOLATILE;
terminal WHILE;

terminal IDENTIFIER;
terminal FLOAT_LITERAL; 
terminal DOUBLE_LITERAL;

terminal CHARLITERAL;
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal SEMICOLON;
terminal COLON;
terminal COMMA;
terminal DOT;
terminal QUESTION;

terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal MOD;

terminal EQEQ;
terminal GTEQ;
terminal LTEQ;
terminal LT;
terminal GT;
terminal OROR;
terminal ANDAND;
terminal AND;
terminal NOT;
terminal NOTEQ;
terminal OR;
terminal XOR;
terminal URSHIFT;
terminal LSHIFT;
terminal RSHIFT;
terminal URSHIFTEQ;

terminal ASSIGNMENT;
terminal MINUSASSIGN;
terminal PLUSASSIGN;
terminal MULTASSIGN;
terminal DIVASSIGN;
terminal MODASSIGN;
terminal ANDASSIGN;
terminal XORASSIGN;
terminal ORASSIGN;
terminal RSHIFTASSIGN;
terminal LSHIFTASSIGN;
terminal AUTOINCRM;
terminal AUTODECRM;
terminal COMP;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;

terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal NULL_LITERAL;

// NON TERMINALS
//DONE
non terminal compilation_unit;
non terminal package_statement;
non terminal import_statement;
non terminal package_name;
non terminal class_name;
non terminal interface_name;
non terminal doc_comment;
non terminal class_declaration;
non terminal interface_declaration;
non terminal type_declaration;
non terminal modifier;
non terminal field_declaration;
non terminal method_declaration;
non terminal constructor_declaration;
non terminal variable_declaration;
non terminal static_initializer;
non terminal type;
non terminal parameter_list;
non terminal statement_block;
non terminal variable_declarator;
non terminal type_specifier;
non terminal parameter;
non terminal statement;

// TODO
non terminal variable_initializer;
non terminal expression;
non terminal if_statement;
non terminal do_statement;
non terminal while_statement;
non terminal for_statement;
non terminal try_statement;
non terminal switch_statement;


//RULES

compilation_unit  ::= 
  package_statement  
  import_statement  
  type_declaration 
;

package_statement  ::= 
  PACKAGE package_name SEMICOLON 
;

import_statement  ::= 
 IMPORT package_name  DOT  MULT  SEMICOLON   
 |   class_name  | interface_name SEMICOLON 
;

type_declaration  ::= 
  doc_comment  class_declaration  | interface_declaration SEMICOLON 
;

//TODO
doc_comment  ::=  "/**" "*/" 
;

class_declaration  ::= 
 modifier CLASS identifier 
 EXTENDS class_name  
 IMPLEMENTS interface_name  COMMA interface_name
 LBRACE   field_declaration   RBRACE
 ; 
 
 package_name ::= 
	identifier 
	|  package_name DOT identifier  
;
 
interface_name ::= 
      identifier 
      |  package_name DOT identifier
;

interface_declaration ::= 
       modifier  INTERFACE identifier 
       EXTENDS interface_name  COMMA interface_name 
       LBRACE  field_declaration  RBRACE
;  

modifier ::= 
      PUBLIC 
      | PRIVATE 
      | PROTECTED 
      | STATIC 
      | FINAL 
      | NATIVE 
      | SYNCHRONIZED 
      | ABSTRACT 
      | THREADSAFE 
      | TRANSIENT 
;

field_declaration ::= 
       doc_comment   method_declaration 
      | constructor_declaration 
      | variable_declaration  
      | static_initializer 
      | SEMICOLON 
;

method_declaration ::= 
      modifier  type identifier 
      LPAREN  parameter_list  RPAREN  LBRACK RBRACK  
      statement_block | SEMICOLON  
;

constructor_declaration ::= 
      modifier identifier LPAREN  parameter_list  RPAREN 
      statement_block 
;

variable_declaration ::= 
       modifier type variable_declarator 
       COMMA variable_declarator SEMICOLON 
;

static_initializer ::= STATIC statement_block
;

type ::= type_specifier LBRACK RBRACK
;

parameter_list ::=  parameter COMMA parameter 
;

statement_block ::= LBRACE statement RBRACE
;
 
 variable_declarator ::= identifier LBRACK RBRACK EQ variable_initializer
;

type_specifier ::= 
 		BOOLEAN 
      | BYTE
      | CHAR 
      | SHORT 
      | INT 
      | FLOAT 
      | LONG 
      | DOUBLE 
      | class_name 
      | interface_name 
;

parameter ::= type identifier LBRACK RBRACK
; 

statement ::= 
         variable_declaration 
      |  expression SEMICOLON
      |  statement_block 
      |  if_statement  
      |  do_statement
      |  while_statement 
      |  for_statement  
      |  try_statement 
      |  switch_statement  
      |  SYNCHRONIZED LPAREN expression RPAREN statement  
      |  RETURN  expression  SEMICOLON  
      |  THROW expression SEMICOLON  
      |  identifier COLON statement  
      |  BREAK  identifier  SEMICOLON  
      |  CONTINUE identifier SEMICOLON  
      |  SEMICOLON 
;