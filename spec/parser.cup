package compiler.generated;
import java_cup.runtime.*;


parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

//TERMINALS

terminal ABSTRACT;
terminal ASSERT;
terminal BOOLEAN;
terminal BREAK;
terminal BYTE;
terminal CASE;
terminal CATCH;
terminal CHAR;
terminal CLASS;
terminal CONST;
terminal CONTINUE;
terminal DEFAULT;
terminal DO;
terminal DOUBLE;
terminal ELSE;
terminal ENUM;
terminal EXTENDS;
terminal FALSE;
terminal FINAL;
terminal FINALLY;
terminal FLOAT;
terminal FOR;
terminal IF;
terminal GOTO;
terminal IMPLEMENTS;
terminal IMPORT;
terminal INSTANCEOF;
terminal INT;
terminal INTERFACE;
terminal LONG;
terminal NATIVE;
terminal NEW;
terminal NULL;
terminal PACKAGE;
terminal PRIVATE;
terminal PROTECTED;
terminal PUBLIC;
terminal RETURN;
terminal SHORT;
terminal STATIC;
terminal SUPER;
terminal SWITCH;
terminal SYNCHRONIZED;
terminal THIS;
terminal THREADSAFE;
terminal THROW;
terminal THROWS;
terminal TRANSIENT;
terminal TRUE;
terminal TRY;
terminal VOID;
terminal VOLATILE;
terminal WHILE;

terminal IDENTIFIER;
terminal FLOAT_LITERAL; 
terminal DOUBLE_LITERAL;

terminal CHARLITERAL;
terminal LPAREN;
terminal RPAREN;
terminal LBRACE;
terminal RBRACE;
terminal LBRACK;
terminal RBRACK;
terminal SEMICOLON;
terminal COLON;
terminal COMMA;
terminal DOT;
terminal QUESTION;

terminal PLUS;
terminal MINUS;
terminal MULT;
terminal DIV;
terminal MOD;

terminal EQEQ;
terminal GTEQ;
terminal LTEQ;
terminal LT;
terminal GT;
terminal OROR;
terminal ANDAND;
terminal AND;
terminal NOT;
terminal NOTEQ;
terminal OR;
terminal XOR;
terminal URSHIFT;
terminal LSHIFT;
terminal RSHIFT;
terminal URSHIFTEQ;

terminal ASSIGNMENT;
terminal MINUSASSIGN;
terminal PLUSASSIGN;
terminal MULTASSIGN;
terminal DIVASSIGN;
terminal MODASSIGN;
terminal ANDASSIGN;
terminal XORASSIGN;
terminal ORASSIGN;
terminal RSHIFTASSIGN;
terminal LSHIFTASSIGN;
terminal AUTOINCRM;
terminal AUTODECRM;
terminal COMP;

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;

terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal NULL_LITERAL;

// NON TERMINALS

non terminal arglist;
non terminal comma_expression;
non terminal expression;
non terminal expression_div;
non terminal arglist_opt;
non terminal numeric_expression;
non terminal numeric_expression_diva;
non terminal numeric_expression_divb;
non terminal numeric_expression_divc;
non terminal arithmetical_op;
non terminal arithmetical_op_equal;
non terminal arithmetical_op_equal_opt;
non terminal testing_expression;
non terminal comparator;
non terminal logical_expression;
non terminal logical_op;
non terminal logical_op_equal;
non terminal logical_op_equal_opt;
non terminal string_expression;
non terminal bit_expression;
non terminal bit_expression_op;
non terminal casting_expression;
non terminal type;
non terminal type_specifier;
non terminal bracks_loop;
non terminal name;
non terminal creating_expression;
non terminal bracks_expression_opt;
non terminal literal_expression;
non terminal class_declaration;
non terminal modifier_loop;
non terminal modifier;
non terminal extends_class_opt;
non terminal implements_interfaces_opt;
non terminal name_loop;
non terminal field_declaration_loop;
non terminal declaration;
non terminal method_declaration;
non terminal param_list_opt;
non terminal parameter;
non terminal parameter_loop;
non terminal end_method_declaration;
non terminal statement_block;
non terminal statement_loop;
non terminal statement;
non terminal variable_declaration;
non terminal variable_declarator;
non terminal variable_declarator_loop;
non terminal variable_initializer;
non terminal variable_initializer_loop;
non terminal variable_initializer_opt;
non terminal comma_opt;
non terminal if_statement;
non terminal else_opt;
non terminal do_statement;
non terminal while_statement;
non terminal for_statement;
non terminal for_init;
non terminal try_statement;
non terminal catch_loop;
non terminal finally_opt;
non terminal switch_statement;
non terminal switch_statement_end;
non terminal switch_statement_end_loop;
non terminal constructor_declaration;
non terminal static_initializer;
non terminal compilation_unit;
non terminal package_statement;
non terminal package_statement_opt;
non terminal import_statement;
non terminal import_statement_loop;
non terminal type_declaration;
non terminal type_declaration_loop;
non terminal interface_declaration;


// RULES

arglist ::=
	expression comma_expression
;

comma_expression ::=
	COMMA expression comma_expression
	|
;

expression ::=
	numeric_expression 
	| testing_expression 
	| logical_expression 
	| string_expression 
	| bit_expression 
	| casting_expression 
	| creating_expression 
	| literal_expression 
	| NULL
	| SUPER 
	| THIS
	| identifier 
	| LPAREN expression RPAREN
	| expression expression_div
;

expression_div ::=
	LPAREN arglist_opt RPAREN 
	| LBRACK expression RBRACK 
	| DOT expression
	| COMMA expression
	| INSTANCEOF name
;

arglist_opt ::=
	arglist
	|
;

numeric_expression ::=
	numeric_expression_diva
	| numeric_expression_divb
	| numeric_expression_divc
;

numeric_expression_diva ::=
	MINUS expression
	| AUTODECRM expression
	| AUTOINCRM expression
;

numeric_expression_divb ::=
	expression AUTODECRM
	| expression AUTOINCRM
;

numeric_expression_divc ::=
	expression arithmetical_op_equal_opt expression
;

arithmetical_op ::=
	PLUS
	| MINUS
	| MULT
	| DIV
	| MOD
;

arithmetical_op_equal ::=
	PLUSASSIGN
	| MINUSASSIGN
	| MULTASSIGN
	| DIVASSIGN
	| MODASSIGN
;

arithmetical_op_equal_opt ::=
	arithmetical_op_equal
	| arithmetical_op
;
	
testing_expression ::=
	expression comparator expression
;

comparator ::=
	GT
	| LT
	| GTEQ
	| LTEQ
	| EQEQ
	| NOTEQ
;

logical_expression ::=
	NOT expression
	| expression logical_op_equal_opt expression
	| expression QUESTION expression COLON expression
	| TRUE
	| FALSE
;

logical_op ::=
	AND
	| OR
	| XOR
	| ANDAND
	| MOD
;

logical_op_equal ::=
	ANDASSIGN
	| ORASSIGN
	| XORASSIGN
	| ORORASSIGN
	| MODASSIGN
;

logical_op_equal_opt ::=
	logical_op_equal
	| logical_op
;

string_expression ::=
	expression PLUS expression
	| expression PLUSASSIGN expression
;

bit_expression ::=
	COMP expression
	| expression bit_expression_op expression
;

bit_expression_op ::=
	RSHIFTASSIGN
	| LSHIFT
	| RSHIFT
	| URSHIFT
;
	
casting_expression ::=
	LPAREN type RPAREN expression
;

type ::=
	type_specifier bracks_loop
;

type_specifier ::=
	BOOLEAN
	| BYTE
	| CHAR
	| SHORT
	| INT
	| FLOAT
	| LONG
	| DOUBLE
	| name
;

name ::=
	IDENTIFIER
	| name DOT IDENTIFIER
;

bracks_loop ::=
	LBRACK RBRACK bracks_loop;
	|
;

creating_expression ::=
	NEW name LPAREN arglist_opt RPAREN
	| NEW type_specifier bracks_expression_opt bracks_loop
	| NEW LPAREN expression RPAREN
;

bracks_expression_opt ::=
	LBRACK expression RBRACK
	|
;

literal_expression ::=
	INTEGER_LITERAL
	| FLOAT_LITERAL
	| STRING_LITERAL
	| CHARLITERAL
;

class_declaration ::=
	modifier_loop CLASS IDENTIFIER extends_class_opt implements_interfaces_opt LBRACE field_declaration_loop RBRACE
;

modifier_loop ::=
	modifier modifier_loop
	|
;

modifier ::=
	PUBLIC
	| PRIVATE
	| PROTECTED
	| STATIC
	| FINAL
	| NATIVE
	| SYNCHRONIZED
	| ABSTRACT
	| THREADSAFE
	| TRANSIENT
;

extends_class_opt ::=
	EXTENDS name
	|
;

implements_interfaces_opt ::=
	IMPLEMENTS name name_loop
;

name_loop ::=
	COMMA name name_loop
	|
}

field_declaration_loop ::=
	declaration
	| static_initializer
	| SEMICOLON
;

declaration ::=
	method_declaration
	| constructor_declaration
	| variable_declaration
;

method_declaration ::=
	modifier_loop type IDENTIFIER LPAREN param_list_opt RPAREN bracks_loop end_method_declaration
;

param_list_opt ::=
	parameter parameter_loop
	|
;

parameter ::=
	type IDENTIFIER bracks_loop
;

parameter_loop ::=
	COMMA parameter parameter_loop
;

end_method_declaration ::=
	statement_block
	| SEMICOLON
;

statement_block ::=
	LBRACE statement_loop RBRACE
;

statement_loop ::=
	statement statement_loop
	|
;

statement ::=
	variable_declaration 
	| expression SEMICOLON
	| statement_block
	| if_statement
	| do_statement
	| while_statement
	| for_statement
	| try_statement
	| switch_statement
	| SYNCHRONIZED LPAREN expression RPAREN statement
	| RETURN expression_opt SEMICOLON
	| THROW expression SEMICOLON
	| identifier COLON statement
	| BREAK identifier_opt SEMICOLON
	| CONTINUE identifier_opt SEMICOLON
	| SEMICOLON
;

variable_declaration ::=
	modifier_loop type variable_declarator variable_declarator_loop SEMICOLON
;

variable_declarator ::=
	IDENTIFIER bracks_loop variable_initializer_opt
;

variable_declarator_loop ::=
	COMMA variable_declarator variable_declarator_loop
	|
;

variable_initializer_opt :==
	ASSIGNMENT variable_initializer
	|
;

variable_initializer ::=
	expression
	| LBRACE RBRACE
	| LBRACE variable_initializer variable_initializer_loop comma_opt RBRACE
;

variable_initializer_loop ::=
	COMMA variable_initializer variable_initializer_loop
	|
;

comma_opt ::=
	COMMA
	|
;

if_statement ::=
	IF LPAREN expression RPAREN statement else_opt
;

else_opt ::=
	ELSE statement
	|
;

do_statement ::=
	DO statement WHILE LPAREN expression RPAREN SEMICOLON
;

while_statement ::=
	WHILE LPAREN expression RPAREN statement
;

for_statement ::=
	FOR LPAREN for_init expression_opt SEMICOLON expression_opt SEMICOLON RPAREN statement
;

for_init ::=
	variable_declaration
	| expression SEMICOLON
	| SEMICOLON
;

try_statement ::=
	TRY statement catch_loop finally_opt
;

catch_loop ::=
	CATCH LPAREN parameter RPAREN statement catch_loop
	|
;

finally_opt ::=
	FINALLY statement
	|
;

switch_statement ::=
	SWITCH LPAREN expression RPAREN LBRACE switch_statement_end switch_statement_end_loop RBRACE
;

switch_statement_end ::=
	CASE expression COLON
	| DEFAULT COLON
	| statement
	|
;

switch_statement_end_loop ::=
	switch_statement_end switch_statement_end_loop
	|
;

constructor_declaration ::=
	modifier_loop IDENTIFIER LPAREN param_list_opt RPAREN statement_block
;

static_initializer ::=
	STATIC statement_block
;

compilation_unit ::=
	package_statement_opt import_statement_loop type_declaration_loop
;

package_statement_opt ::=
	package_statement
	|
;

package_statement ::=
	PACKAGE name SEMICOLON
;

import_statement_loop ::=
	import_statement import_statement_loop
	|
;

import_statement ::=
	IMPORT name DOT MULT SEMICOLON SEMICOLON
	| IMPORT name SEMICOLON
;

type_declaration_loop ::=
	type_declaration type_declaration_loop
	|
;

type_declaration ::=
	class_declaration SEMICOLON
	| interface_declaration SEMICOLON
;

interface_declaration ::=
	modifier_loop INTERFACE IDENTIFIER EXTENDS name name_loop LBRACE field_declaration_loop RBRACE
;