parser code  {: 
  public void report_error(String message, Object info) {
    StringBuffer m = new StringBuffer("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

terminal BOOLEAN; // 
terminal BYTE, SHORT, INT, LONG, CHAR; // OK
terminal D, E, F, X, L; // 
terminal TRUE, FALSE; //  
terminal NULL; // ok
terminal FLOAT, DOUBLE; // 
terminal LBRACK, RBRACK; // 
terminal DOT; // 
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal PACKAGE; //
terminal IMPORT; // ok
terminal PUBLIC, PROTECTED, PRIVATE, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, THREADSAFE; //OK
terminal CLASS; // ok
terminal EXTENDS; // ok
terminal IMPLEMENTS; // ok
terminal VOID; // method_header
terminal THROWS; // throws
terminal THIS, SUPER; // ok
terminal INTERFACE; // ok
terminal IF, ELSE; // ok
terminal SWITCH; // 
terminal CASE, DEFAULT; // 
terminal DO, WHILE; // 
terminal FOR; // for_statement
terminal BREAK; // break_statement
terminal CONTINUE; // continue_statement
terminal RETURN; // return_statement
terminal THROW; // throw_statement
terminal TRY; // try_statement
terminal CATCH; // catch_clause
terminal FINALLY; // finally
terminal NEW; // class_instance_creation_expression
terminal PLUS, MINUS, COMP, NOT, DIV, MOD, PLUSPLUS, MINUSMINUS; //ok
terminal LSHIFT, RSHIFT, URSHIFT, RSHIFTEQ; // ok
terminal LT, GT, LTEQ, GTEQ, EQEQ, NOTEQ, INSTANCEOF; // ok
terminal AND, XOR, OR;  // ok
terminal ANDAND,  OROR; // ok
terminal ANDEQ, XOREQ, OREQ; // ok
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ, QUESTION; // ok
terminal LSHIFTEQ, URSHIFTEQ; // 
terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character character; //ok
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String CHARLITERAL;
terminal java.lang.String identifier; // ok
terminal NULL_LITERAL;




// 19.2) The Syntactic Grammar
non terminal goal;

// 19.3) Lexical Structure
non terminal literal;

// 19.4) Types, Values, and Variables
non terminal type; // ok
non terminal type_specifier; //ok
non terminal arglist; //ok

// 19.6) Packages
non terminal compilation_unit; //ok
non terminal package_name; //ok
non terminal package_statement_opt; // ok
non terminal package_statement; //ok
non terminal import_statement; //ok
non terminal type_declaration; //ok
non terminal modifier;

// 19.8.1) Class Declaration
non terminal class_name;  //ok
non terminal class_or_interface_declaration, class_declaration; //ok

// 19.8.2) Field Declarations
non terminal field_declaration; //ok
non terminal variable_declaration, variable_declarator, variable_declarator_loop; // ok
non terminal comma_opt, variable_initializer, variable_initializer_opt, eq_variable_initializer_opt; //ok
non terminal variable_declarator_id; //ok

// 19.8.3) Method Declarations
non terminal method_declaration, parameter_list, parameter_list_opt; //ok

// 19.8.4) Static Initializers
non terminal static_initializer; //ok

// 19.8.5) Constructor Declarations
non terminal constructor_declaration; // ok

// 19.9.1) Interface Declarations
non terminal interface_type_list, interfaces, interface_opt ;// ok
non terminal interface_name; //ok
non terminal interface_declaration; // ok

// 19.11) Blocks and Statements
non terminal statement, statement_block; //ok
non terminal if_statement; //ok
non terminal else_opt; //ok
non terminal switch_statement, switch_body; // ok
non terminal do_statement; //ok
non terminal for_statement, while_statement, try_statement; // ok
non terminal finally_opt; //ok
non terminal identifier_opt; //ok

// 19.12) Expressions
non terminal expression_opt, expression; //ok
non terminal bit_expression; //ok
non terminal casting_expression; //ok
non terminal creating_expression; // ok
non terminal numeric_expression; // ok
non terminal testing_expression; // ok
non terminal logical_expression; // ok
non terminal string_expression, string_op; // ok

//Aux
non terminal exponent_part, doc_comment_opt;
non terminal sttm_block_semicolon; //ok
non terminal minus_exp, minusminus_exp, plusplus_exp, exp_minusminus, exp_plusplus; //ok
non terminal arglist_opt, class_or_interface_name; 
non terminal interface_type;
non terminal extends_class_opt;
non terminal expression_bracks_opt;
non terminal literal_expression;
non terminal types_declarations;
non terminal expression_semicolon;
non terminal part_for;
non terminal extends_interfaces_opt;
non terminal interface_body;
non terminal extends_interfaces;
non terminal interface_member_declarations_opt;
non terminal interface_member_declarations;
non terminal parameter;
non terminal case_opt;
non terminal doc_comment;
start with goal
;
goal ::= compilation_unit
;
     
//RULES

modifier  ::=  PUBLIC   | PRIVATE   | PROTECTED   | STATIC  | FINAL 
      | NATIVE    | SYNCHRONIZED    | ABSTRACT  | THREADSAFE   | TRANSIENT ;

expression ::= 
      | identifier 
      | LPAREN expression RPAREN  
      | expression LPAREN arglist_opt RPAREN 
      | expression LBRACK expression RBRACK 
      | expression DOT expression 
      | expression COMMA expression 
      | expression INSTANCEOF class_or_interface_name ;


arglist ::= 
      expression
      | arglist COMMA expression
     ;

arglist_opt ::= | arglist ;
     
bit_expression ::= 
      COMP expression 
      | expression RSHIFTEQ expression
      | expression LSHIFT expression
      | expression RSHIFT expression
      | expression URSHIFT expression 
     ;
     
casting_expression ::= 
      LPAREN type RPAREN expression 
     ; 
     
extends_class_opt ::= | EXTENDS class_name ;

interface_type_list ::= interface_type | interface_type_list COMMA interface_type; //ok
interfaces ::=	IMPLEMENTS interface_type_list; //ok
interface_opt ::= | interfaces ; //ok

class_declaration ::= 
      modifier CLASS identifier 
      extends_class_opt
      interface_opt
      LBRACE field_declaration RBRACE
      ;

class_or_interface_name ::= 
      identifier 
      | package_name DOT identifier 
     ;
     
class_name ::= class_or_interface_name;

interface_name ::= class_or_interface_name;

package_statement_opt ::= | package_statement;
compilation_unit ::= 
      package_statement_opt
      import_statement 
      type_declaration 
     ;
     
constructor_declaration ::= 
      modifier identifier LPAREN parameter_list_opt RPAREN
      statement_block 
     ;
     


expression_bracks_opt ::= | LBRACK expression RBRACK ;
creating_expression ::= 
      NEW class_name LPAREN arglist_opt RPAREN 
      | NEW type_specifier expression_bracks_opt LBRACK RBRACK 
      | NEW LPAREN expression RPAREN 
	;
	
do_statement ::=
		DO statement WHILE LPAREN expression RPAREN SEMICOLON
	;
	

	

class_or_interface_name ::= class_name | interface_name ;
expression ::= 
      numeric_expression 
      | testing_expression 
      | logical_expression 
      | string_expression 
      | bit_expression 
      | casting_expression 
      | creating_expression 
      | literal_expression 
      | NULL 
      | SUPER 
      | THIS 
      | identifier 
      | LPAREN expression RPAREN  
      | expression LPAREN arglist_opt RPAREN 
      | expression LBRACK expression RBRACK 
      | expression DOT expression 
      | expression COMMA expression 
      | expression INSTANCEOF class_or_interface_name 
	;
	
types_declarations ::= 
	  method_declaration 
      | constructor_declaration 
      | variable_declaration 
	;
	
field_declaration ::= 
      types_declarations 
      | static_initializer 
      | SEMICOLON
     ;

expression_opt ::= | expression ;
expression_semicolon ::= expression SEMICOLON ;

part_for ::= variable_declaration | expression_semicolon | SEMICOLON ;
for_statement ::= 
      FOR LPAREN  
      part_for  
      expression_opt SEMICOLON
      expression_opt SEMICOLON 
      RPAREN statement 
	;
	
else_opt ::= | ELSE statement ;
if_statement ::= 
      IF LPAREN expression RPAREN statement 
      else_opt 
     ;
     
import_statement ::= 
     IMPORT package_name DOT MULT SEMICOLON
     | IMPORT class_name SEMICOLON
     | IMPORT interface_name SEMICOLON
	;      
	
interface_declaration ::=
		modifier INTERFACE identifier extends_interfaces_opt 
			interface_body
	;
extends_interfaces_opt ::=
	|	extends_interfaces
	;
extends_interfaces ::=
		EXTENDS interface_name
	|	extends_interfaces COMMA interface_name
	;
	
interface_body ::=
		LBRACE interface_member_declarations_opt RBRACE
	;
interface_member_declarations_opt ::=
	|	interface_member_declarations
	;
interface_member_declarations ::=
		field_declaration
	|	interface_member_declarations field_declaration
	;
	  
interface_name ::= 
      identifier 
      |  package_name DOT identifier
	;

literal_expression ::=   INTEGER_LITERAL  | FLOATING_POINT_LITERAL 
      | STRING_LITERAL               //VEEER
      | character ; //ok
	
logical_expression ::= 
       NOT expression 
      | expression AND expression
      | expression ANDEQ expression 
      | expression OR expression
      | expression OREQ expression 
      | expression XOR expression
      | expression XOREQ expression 
      | expression ANDAND expression
      | expression OROR expression 
      | expression MOD expression
      | expression MODEQ expression 
      | expression QUESTION expression COLON expression
      | TRUE 
      | FALSE 
	; //ok

parameter_list_opt ::= | parameter_list; //ok
sttm_block_semicolon ::= statement_block | SEMICOLON ; //ok
method_declaration ::= 
		modifier type identifier 
		LPAREN parameter_list_opt RPAREN LBRACK RBRACK
		sttm_block_semicolon
	; //estranhissimo ok

minus_exp ::=  MINUS expression; //ok
minusminus_exp ::=  MINUSMINUS expression; //ok
plusplus_exp ::=  PLUSPLUS expression; //ok
exp_minusminus ::=   expression MINUSMINUS; //ok
exp_plusplus ::=   expression PLUSPLUS; //ok

numeric_expression ::= 
      minus_exp
      | minusminus_exp
      | plusplus_exp 
      | exp_plusplus
      | exp_minusminus
      | expression PLUS expression
      | expression PLUSEQ expression 
      | expression MINUS expression 
      | expression MINUSEQ expression
      | expression MULT expression
      | expression MULTEQ expression 
      | expression DIV expression
      | expression DIVEQ expression
      | expression MOD expression 
      | expression MODEQ expression  
	; //ok
	
package_name ::= 
      identifier 
      | package_name DOT identifier 
	;
	
package_statement ::= 
      PACKAGE package_name SEMICOLON
     ; //ok

parameter ::= 
      type identifier LBRACK RBRACK |
      type identifier
	;  //ok
	
parameter_list ::= parameter |
      parameter COMMA parameter_list 
	; //ok
	
identifier_opt ::= | identifier
	;
	
statement ::=	
	variable_declaration
	|	expression SEMICOLON
	|   statement_block
	|	if_statement
	|	do_statement
	|	while_statement
	|	for_statement
	|	try_statement
	|	switch_statement
	|	SYNCHRONIZED LPAREN expression RPAREN statement
	|	RETURN expression_opt SEMICOLON   
	|	THROW expression SEMICOLON
	|   identifier COLON statement
	|	BREAK identifier_opt SEMICOLON 
    |   CONTINUE identifier_opt SEMICOLON 
    |   SEMICOLON 
	;
	
statement_block  ::=
		LBRACE statement RBRACE
	;

static_initializer ::=
		STATIC statement_block 
	;

string_op ::= PLUS | PLUSEQ ;

string_expression ::= expression string_op  expression;

case_opt ::= | CASE expression COLON;
    
switch_body ::= DEFAULT COLON | statement;

switch_statement ::=
        SWITCH LPAREN expression RPAREN LBRACE 
        case_opt switch_body RBRACE;
        
testing_expression ::= 
     expression GT expression
     | expression LT expression
     | expression GTEQ expression
     | expression LTEQ expression
     | expression EQEQ expression
     | expression NOTEQ expression;
      
finally_opt ::= | FINALLY statement;
try_statement ::=
		TRY statement LBRACE CATCH LPAREN parameter RPAREN statement RBRACE
      	finally_opt;

type ::= 
      type_specifier
      | type_specifier LBRACK RBRACK;
      
doc_comment_opt ::= | doc_comment ;
class_or_interface_declaration ::= class_declaration | interface_declaration;
type_declaration ::= 
      doc_comment_opt class_or_interface_declaration SEMICOLON 
     ;

type_specifier ::= 
      BOOLEAN 
      | BYTE 
      | CHAR 
      | SHORT 
      | INT 
      | FLOAT 
      | LONG 
      | DOUBLE 
      | class_or_interface_name ;
      
variable_declaration ::=
		modifier type variable_declarator_loop |
		type variable_declarator_loop;

variable_declarator_loop ::= variable_declarator | variable_declarator COMMA variable_declarator_loop ;
variable_declarator ::=
		identifier eq_variable_initializer_opt
		| identifier LBRACK RBRACK eq_variable_initializer_opt
		| identifier LBRACK RBRACK;
		
variable_initializer ::=
		expression
	|	LBRACE variable_initializer_opt comma_opt  RBRACE;
			
eq_variable_initializer_opt ::= | EQ variable_initializer ;
		
comma_opt ::= | COMMA;

variable_initializer_opt ::= variable_initializer | variable_initializer 
      COMMA variable_initializer_opt  
 	;

while_statement ::=
		WHILE LPAREN expression RPAREN statement;
	