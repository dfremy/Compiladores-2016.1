package compiler.generated;
import java_cup.runtime.*;


parser code {:
    
    public void report_error(String message, Object info) {
   
        StringBuffer m = new StringBuffer("Error");
   
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                /* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
                m.append(" in line "+(s.left+1));   
                /* Check if the column number in the input is greater
                   or equal to zero. */
                if (s.right >= 0)                    
                    /* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
                    m.append(", column "+(s.right+1));
            }
        }
   

        m.append(" : "+message);
        System.err.println(m);
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};

//TERMINALS

terminal BOOLEAN; // primitive_type
terminal BYTE, SHORT, INT, LONG, CHAR; // integral_type
terminal D, E, F, X, L; // number representation
terminal TRUE, FALSE; // boolean terminals 
terminal NULL; // null terminal
terminal THREADSAFE; // threadsafe terminal
terminal FLOAT, DOUBLE; // floating_point_type
terminal LBRACK, RBRACK; // array_type
terminal DOT; // qualified_name
terminal SEMICOLON, MULT, COMMA, LBRACE, RBRACE, EQ, LPAREN, RPAREN, COLON;
terminal PACKAGE; // package_declaration
terminal IMPORT; // import_declaration
terminal PUBLIC, PROTECTED, PRIVATE; // modifier
terminal STATIC; // modifier
terminal ABSTRACT, FINAL, NATIVE, SYNCHRONIZED, TRANSIENT, VOLATILE;
terminal CLASS; // class_declaration
terminal EXTENDS; // super
terminal IMPLEMENTS; // interfaces
terminal VOID; // method_header
terminal THROWS; // throws
terminal THIS, SUPER; // explicit_constructor_invocation
terminal INTERFACE; // interface_declaration
terminal IF, ELSE; // if_then_statement, if_then_else_statement
terminal SWITCH; // switch_statement
terminal CASE, DEFAULT; // switch_label
terminal DO, WHILE; // while_statement, do_statement
terminal FOR; // for_statement
terminal BREAK; // break_statement
terminal CONTINUE; // continue_statement
terminal RETURN; // return_statement
terminal THROW; // throw_statement
terminal TRY; // try_statement
terminal CATCH; // catch_clause
terminal FINALLY; // finally
terminal NEW; // class_instance_creation_expression
terminal PLUSPLUS; // postincrement_expression
terminal MINUSMINUS; // postdecrement_expression
terminal PLUS, MINUS, COMP, NOT, DIV, MOD;
terminal LSHIFT, RSHIFT, URSHIFT; // shift_expression
terminal LT, GT, LTEQ, GTEQ, INSTANCEOF; // relational_expression
terminal EQEQ, NOTEQ; // equality_expression
terminal AND; // and_expression
terminal XOR; // exclusive_or_expression
terminal OR;  // inclusive_or_expression
terminal ANDAND; // conditional_and_expression
terminal OROR; // conditional_or_expression
terminal QUESTION; // conditional_expression
terminal MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator
terminal LSHIFTEQ, RSHIFTEQ, URSHIFTEQ; // assignment_operator
terminal ANDEQ, XOREQ, OREQ; // assignment_operator

terminal java.lang.Number INTEGER_LITERAL;
terminal java.lang.Number FLOATING_POINT_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.Character CHARACTER_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER; // name
terminal NULL_LITERAL;

// NON TERMINALS
//DONE
non terminal compilation_unit;
non terminal package_statement;
non terminal import_statement;
non terminal package_name;
non terminal class_name;
non terminal interface_name;
non terminal doc_comment;
non terminal class_declaration;
non terminal interface_declaration;
non terminal type_declaration;
non terminal identifier;
non terminal modifier;
non terminal field_declaration;
non terminal method_declaration;
non terminal constructor_declaration;
non terminal variable_declaration;
non terminal static_initializer;
non terminal type;
non terminal parameter_list;
non terminal statement_block;
non terminal variable_declarator;
non terminal type_specifier;
non terminal parameter;
non terminal statement;
non terminal variable_initializer;
non terminal expression;
non terminal if_statement;
non terminal do_statement;
non terminal while_statement;
non terminal for_statement;
non terminal expression_opt;
non terminal try_statement;
non terminal finally_statement_opt;
non terminal switch_statement;
non terminal numeric_expression;
non terminal testing_expression;
non terminal logical_expression;
non terminal string_expression;
non terminal bit_expression;
non terminal casting_expression;
non terminal creating_expression;
non terminal arglist_opt;
non terminal expression_brack_opt;
non terminal literal_expression;
non terminal arglist;
non terminal integer_literal;
non terminal decimal_digits_opt;
non terminal exponent_part_opt;
non terminal float_type_suffix_opt;
non terminal float_literal;
non terminal string;
non terminal character;
non terminal decimal_digits;
non terminal exponent_part;
non terminal float_type_suffix;
non terminal extends_opt;
non terminal implements_opt;
non terminal implements_compl;
non terminal package_statement_opt;
non terminal parameter_list_opt;
non terminal doc_comment_opt;
non terminal else_statement_opt;
non terminal extends_interface_opt;
non terminal extends_mult_interface_opt;
non terminal return_expression_opt;
non terminal identifier_opt;
non terminal eq_variable_initializer_opt;
non terminal variable_comma_opt;
non terminal variable_mult_comma;
non terminal variable_initializer_opt;
non terminal import_statement_opt;
non terminal type_declaration_opt;
non terminal modifiers_opt;
non terminal modifiers;

//RULES

package_statement_opt ::= | package_statement
;
compilation_unit  ::= 
  package_statement_opt  
  import_statement_opt  
  type_declaration_opt 
;

package_name ::= 
	identifier 
	|  package_name DOT identifier  
;

package_statement  ::= 
  PACKAGE package_name SEMICOLON 
;

import_statement_opt ::= | import_statement
;
import_statement  ::= 
 IMPORT package_name  DOT  MULT  SEMICOLON   
 |   class_name  | interface_name SEMICOLON 
;

doc_comment_opt ::= | doc_comment
;
type_declaration_opt ::= | type_declaration
;
type_declaration  ::= 
  doc_comment_opt  class_declaration  | interface_declaration SEMICOLON 
;

doc_comment  ::=  "/**" "*/" 
;

extends_opt ::= | EXTENDS class_name
;
implements_opt ::= |  IMPLEMENTS interface_name implements_compl
; 
implements_compl ::=  | COMMA interface_name
;
class_declaration  ::= 
 modifiers_opt CLASS identifier 
 extends_opt
 implements_opt  
 LBRACE   field_declaration   RBRACE
 ; 
 
interface_name ::= 
      identifier 
      |  package_name DOT identifier
;

extends_interface_opt ::= | EXTENDS interface_name extends_mult_interface_opt
;
extends_mult_interface_opt ::= |  COMMA interface_name
;
interface_declaration ::= 
       modifiers_opt  INTERFACE identifier 
       extends_interface_opt
       LBRACE  field_declaration  RBRACE
;  

modifiers_opt::=
	|	modifiers
	;
modifiers ::= 	modifier
	|	modifiers modifier
	;
modifier ::=	PUBLIC | PROTECTED | PRIVATE
	|	STATIC
	|	ABSTRACT | FINAL | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE
	|THREADSAFE
	;

field_declaration ::= 
       doc_comment_opt   method_declaration 
      | constructor_declaration 
      | variable_declaration  
      | static_initializer 
      | SEMICOLON 
;

parameter_list_opt ::= | parameter_list
;
method_declaration ::= 
      modifiers_opt  type identifier 
      LPAREN  parameter_list_opt  RPAREN  LBRACK RBRACK  
      statement_block | SEMICOLON  
;

constructor_declaration ::= 
      modifiers_opt identifier LPAREN  parameter_list_opt  RPAREN 
      statement_block 
;

variable_declaration ::= 
       modifiers_opt type variable_declarator 
       COMMA variable_declarator SEMICOLON 
;

static_initializer ::= STATIC statement_block
;

type ::= type_specifier LBRACK RBRACK
;

parameter_list ::=  parameter COMMA parameter 
;

statement_block ::= LBRACE statement RBRACE
;
 
eq_variable_initializer_opt ::= | EQ variable_initializer
;
 variable_declarator ::= identifier LBRACK RBRACK eq_variable_initializer_opt 
;

type_specifier ::= 
 		BOOLEAN 
      | BYTE
      | CHAR 
      | SHORT 
      | INT 
      | FLOAT 
      | LONG 
      | DOUBLE 
      | class_name 
      | interface_name 
;

parameter ::= type identifier LBRACK RBRACK
; 

return_expression_opt ::= | expression
;
identifier ::= IDENTIFIER
;
identifier_opt ::= | identifier
;
statement ::= 
         variable_declaration 
      |  expression SEMICOLON
      |  statement_block 
      |  if_statement  
      |  do_statement
      |  while_statement 
      |  for_statement  
      |  try_statement 
      |  switch_statement  
      |  SYNCHRONIZED LPAREN expression RPAREN statement  
      |  RETURN  return_expression_opt  SEMICOLON  
      |  THROW expression SEMICOLON  
      |  identifier COLON statement  
      |  BREAK  identifier_opt  SEMICOLON  
      |  CONTINUE identifier_opt SEMICOLON  
      |  SEMICOLON 
;

variable_comma_opt ::= | COMMA
;
variable_mult_comma ::= | COMMA variable_initializer
;
variable_initializer_opt ::=variable_initializer variable_mult_comma  
							variable_comma_opt
;  
variable_initializer ::= 
      expression 
      | LBRACE  variable_initializer_opt RBRACE
;

arglist_opt ::= | arglist
;
expression ::= 
      numeric_expression 
      | testing_expression 
      | logical_expression 
      | string_expression 
      | bit_expression 
      | casting_expression 
      | creating_expression 
      | literal_expression 
      | NULL 
      | SUPER 
      | THIS 
      | identifier 
      | LPAREN expression RPAREN 
      | expression LPAREN arglist_opt RPAREN 
      | LBRACK expression RBRACK 
      | DOT expression 
      | COMMA expression 
      | INSTANCEOF class_name | interface_name  
;
class_name ::= 
      identifier 
      | package_name DOT identifier 
;

else_statement_opt ::= | ELSE statement
; 
if_statement ::= 
      IF LPAREN expression RPAREN statement
      else_statement_opt 
;

do_statement ::= 
      DO statement WHILE LPAREN expression RPAREN SEMICOLON 
;
while_statement ::= 
      WHILE LPAREN expression RPAREN statement 
;

expression_opt ::= |expression
;

for_statement ::= 
      FOR LPAREN variable_declaration |  expression SEMICOLON  | SEMICOLON 
      expression_opt  SEMICOLON
      expression_opt  SEMICOLON
      RPAREN statement 
;
finally_statement_opt::= | FINALLY statement
;

try_statement ::= 
      TRY statement 
      CATCH LPAREN parameter RPAREN statement
      finally_statement_opt
;

switch_statement ::= 
      SWITCH LPAREN expression RPAREN LBRACE 
      CASE expression COLON 
      | DEFAULT COLON 
      | statement 
      RBRACE
;

numeric_expression ::= 
      MINUS 
      | PLUSPLUS
      | MINUSMINUS expression 
      | expression PLUSPLUS 
      | MINUSMINUS 
      | expression PLUS 
      | PLUSEQ 
      | MINUS 
      | MINUSEQ
      | MULT 
      | MULTEQ 
      | DIV 
      | DIVEQ 
      | MOD 
      | MODEQ 
      expression 
;

testing_expression ::= 
     expression GT expression
     | expression LT expression
     | expression GTEQ expression
     | expression LTEQ expression
     | expression EQEQ expression
     | expression NOTEQ expression
;

logical_expression ::= 
      NOT expression 
      | expression AND 
      | ANDEQ 
      | OR 
      | OREQ 
      | XOR 
      | XOREQ 
      | AND AND 
  /*    | OROREQ*/ 
      | MOD 
      | MODEQ 
      expression 
      | expression QUESTION expression COLON expression 
      | TRUE 
      | FALSE
; 

string_expression ::= 
	  expression 
	  PLUS | PLUSEQ 
      expression
; 

bit_expression ::= 
      COMP expression 
      | expression RSHIFTEQ
      | LSHIFT 
      | RSHIFT 
      | URSHIFT  
      expression
; 

casting_expression ::= 
     LPAREN type RPAREN expression 
;

expression_brack_opt ::= | LBRACK expression RBRACK
;
creating_expression ::= 
      NEW  class_name LPAREN arglist_opt RPAREN ) 
      | type_specifier expression_brack_opt  LBRACK RBRACK 
      | LPAREN expression RPAREN 
;

literal_expression ::=	
		INTEGER_LITERAL
	|	FLOATING_POINT_LITERAL
	|	BOOLEAN_LITERAL
	|	CHARACTER_LITERAL
	|	STRING_LITERAL
	|	NULL_LITERAL
;

arglist ::= expression  COMMA expression
; 

integer_literal ::= INTEGER_LITERAL
      /*| { "0..7" } 
      | ( "0" "x" "0..9a..f" { "0..9a..f" } ) ) 
      [ "l" ] 
*/
;

decimal_digits_opt ::= | decimal_digits
;
exponent_part_opt ::= | exponent_part
;
float_type_suffix_opt ::= |float_type_suffix
;
float_literal ::= 
      decimal_digits DOT decimal_digits_opt exponent_part_opt float_type_suffix_opt 
      | DOT decimal_digits_opt exponent_part_opt float_type_suffix_opt 
      | decimal_digits_opt exponent_part_opt float_type_suffix_opt 
 ;
 
 string ::= STRING_LITERAL
 ;
 
 character ::= CHARACTER_LITERAL
 ; 
 
decimal_digits ::= INTEGER_LITERAL
;
/*float_type_suffix ::= "f" | "d"
;

plus_minus_opt :== | PLUS | MINUS
;
exponent_part ::= 
      "e" plus_minus_opt decimal_digits
;*/